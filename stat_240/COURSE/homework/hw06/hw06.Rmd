---
author: "vardaan kapoor"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE,
                      warning = FALSE, error = TRUE,
                      fig.height = 3)
library(tidyverse)
library(lubridate)
source("../../scripts/viridis.R")
```

## Assignment 6

#### Due Sunday, March 26, 11:59 PM CT

### Preliminaries

- Directories
    - COURSE/homework/
    - COURSE/homework/hw06/
    - COURSE/data/
    - COURSE/scripts/
- Files
  - COURSE/homework/hw06/hw06.Rmd
  - COURSE/data/exoplanets-clean-through-2022.csv
  - COURSE/data/wordle.csv
  - COURSE/scripts/viridis.R

### Aims

- Practice strings and regular expressions


### Problems

Problems 1--4 are based on a data frame with the names of built-in R colors.
  
```{r}
df_colors = tibble(color = colors()) %>% 
  mutate(index = row_number(), .before = color)
```

  1. Create a data frame with the names of all colors whose names are exactly 7 characters long. Print a summary of this data frame with the number of colors and the first and last alphabetically in the list.
  
```{r}
df_colors
df_colors_7=df_colors %>% filter(str_length(color)==7) %>% arrange(color)
df_colors_7 %>% summarize(n=n(),first=min(color),last=max(color))
```
  
  






  2. How many of the previous color names contain no digits? Create a second data frame which eliminates the rows from your solution to the previous problem any color names which contain a digit. Print a summary of this data frame with the number of colors and the first and last alphabetically in the list.

```{r}
df_colors_nd=df_colors_7 %>% filter(!str_detect(color,"[:digit:]")) %>%  arrange(color)
df_colors_nd
df_colors_nd %>%  summarize(n=n(),first=min(color),last=max(color))
```





  3. Find all colors which contain consecutive letters "e". Print a summary with a count of how many such colors there are and the first and last alphabetically.
  
```{r}
df_duplicate=df_colors %>%  filter(str_detect(color,"([e])\\1"))
df_duplicate
df_duplicate %>%  summarize(n=n(),first=min(color),last=max(color))
```



  
  
  4. Find all color names which contain any consecutive identical letters. Create a data frame with these colors.
  
- Print the first ten rows of this data frame
- Tabulate how often each letter is used in a consecutive letter pair and print out this table arranged in descending order of the counts.
- Identify the three color names which have a distinct pair of consecutive identical letters. (These are the only color names which use the given letter pair.)
  
```{r}
df_duplicate_any=df_colors %>%  filter(str_detect(color,"([:alpha:])\\1"))
df_duplicate_any %>%  print(n=10,width = Inf)
df_duplicate_any=df_duplicate_any %>%  mutate(consecutive=str_extract(color,"([:alpha:])\\1"))
df_duplicate_any
#note:extract extracts only the first occuring instance of the pattern-but the extract_all method extracts all the instances of te pattern in the vector string
df_summarized_number=df_duplicate_any %>%  drop_na() %>% group_by(consecutive) %>%  summarize(index,color,n=n())
df_summarized_number_all=df_summarized_number %>% arrange(desc(n),index)
df_summarized_number_all
df_3_words=df_summarized_number_all %>%  filter(n==1) %>%  ungroup() %>% arrange(desc(n))%>% select(color)
df_3_words
#create a vector which contains all the consecutive pairs which occur only once-cc,dd,kk
#then get all the colors which contain these pairs-so as they occur only once-they give only 3 color names
#df_duplciate_count=df_duplicate %>% str_co
```




  
  5. Load the exoplanet data set from the file `exoplanets-clean-through-2022.csv`. Create a new data frame by selecting only the columns `id` and `star`. Find and print all rows where the name in `star` does not match the string in `star` treated as a regular expression.
  
- What seems to be the common characteristic of such star names?

After identifying this characteristic, add a column to the `planets` data frame with the name `star_regex` which, when treated as a regular expression, does match the literal star name exactly. Such a regular expression should begin with `^` and end with `$`. Verify that each star name is matched by the regular expression.
  
```{r functiongetspecial}
getspecial=function(starname)
{
  int_df=planets %>% filter(!str_detect(star,star))
  
  return (int_df)
}
```
  
```{r}
planets = read_csv("../../data/exoplanets-clean-through-2022.csv")
planets
planets_cut=planets %>% select(id,star) %>% group_by(star) %>% filter(!str_detect(star,str_c("^",star,"$")))
planets_cut

```
all the start names have a + inserted in their names due to which the str_detect function detects them in the wrong sense

```{r}
#planets_cut2=planets %>% select(id,star) %>% group_by(star) %>%  filter(str_detect(star,"HATS-22"))
#planets_cut2
#planets_regex=planets %>% mutate(special=str_extract(star,"[:punct:]")) %>%  mutate(star_regex=case_when(str_detect(star,special)~str_replace(star,special,str_c("\\","\\",special))))
#planets_regex=planets %>% mutate(star_regex=str_replace(star,"\\+",str_c("","\\+")))
planets=planets %>% mutate(star_regex=str_c("^",str_replace(star,"\\+","\\\\+"),"$"))
planets
planets_check=planets %>% filter(!str_detect(star,star_regex)) %>% summarize(count=n())
planets_check
#planets_check
#mutate(regex_suffix=str_c("\",special)) %>%
#replace the special characters with \special so that they are interpreted literally-use str_replace and str_c to combine the parts
```






  6. Most planets have a name equal to the star name followed by a space and a single lower case letter. Identify all planets for which this pattern is not true.
  
- Print the columns `id`, `planet`, `star`, and `year` for all planets in `planets` which do not fit this pattern.
  
- How many of the 5240 exoplanets do not follow the typical convention?
  
  
```{r}
exo_match=planets %>%  mutate(regex=str_c("^",str_replace(star,"\\+","\\\\+"),"[:space:]","[a-z]" ,"$")) %>% filter(!str_detect(planet,regex)) %>%select(id,planet,star,year)
exo_match#correct answer dataframe
exo_match_int=planets %>% filter(str_detect(planet,"^.*[:space:][a-z]$"))
exo_match_int
exo_match_int2=planets %>% filter()
#exo_match2=planets %>% mutate(check=star,str_c("\\^",star,"\\[:space:\\]","\\\\[a-z\\\\]","\\\\$"))
#exo_match2
#exo_match3=exo_match2 %>% filter(str_detect(star,str_c("\\\\^",star,"\\\\[:space:\\\\]","\\\\[a-z\\\\]","\\\\$")))
#exo_match3
```


  there are 48 planets in the queried dataset
  



  7. For the planets whose names **do match** the pattern from the previous problem, create a table which counts the frequency of the last lower case letters in the planet name. Display this data with an effective graph.
  
  
  
```{r}
#count_match_planets=planets %>% anti_join(exo_match,by="planet")
#count_freq=count_match_planets %>% mutate(last=str_extract(planet,"[a-z]$"),count=str_count(planet,"[a-z]$"))
#count_freq2=count_freq %>% drop_na() %>% group_by(last) %>% summarize(count_last=n())
#ggplot(count_freq2,aes(x=last,y=count_last))+geom_col()

count_match_method2=planets %>% anti_join(exo_match,by="planet")
count_match_method2=count_match_method2%>%mutate(last=str_extract(planet,"[a-z]$"))%>%group_by(last) %>% summarize(count_last=n())
count_match_method2
ggplot(count_match_method2,aes(x=last,y=count_last))+geom_col(fill="red")

```




  8. The file `wordle_data.csv` contains the original solution list to the game Wordle.
In the game, players attempt to identify a secret five-letter word by guessing a word and using the color-coded information returned.
A green letter from the guess is in the correct location in the secret word.
A yellow letter from the guess is in the secret word, but is not in the correct location.
A gray letter is not in the word (unless a guess contains multiple copis of the same letter and at least one letter is colored and another is gray).

In a puzzle, the guess information is return for these first two guesses.

- SLATE returns the pattern Gray, Gray, Gray, Yellow, Gray
- COUNT returns the pattern Yellow, Green, Gray, Gray, Yellow

*(Note that the words in the data base have all lower case letters.)*

Find all possible solutions in `wrdl` which are consistent with the information given.

*Hint: you may find it easiest to pipe the word list through multiple `filter()` commands instead of trying to create a single regular expression which only matches all possible solutions. For example, you know the secret word contains at least one `T` and this letter is not in the 4th or 5th positions, at least one `C` which is not the first letter, and that the second letter is an `O`. You also know several letters which are not contained in the secret word.*

```{r}
wrdl = read_csv("../../data/wordle_data.csv") %>% 
  filter(solution == TRUE) %>% 
  select(word)
 wrdl=wrdl %>% filter(str_detect(word,"([^slae]){5}") & str_detect(word,"^.{3}[^t]")) %>% filter(str_detect(word,"([^un]){5}")&str_detect(word,"[^c][o].{2}[^t]"))
 wrdl
```




